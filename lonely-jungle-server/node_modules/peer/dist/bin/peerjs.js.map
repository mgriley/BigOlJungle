{"mappings":"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","sources":["src/config/index.ts","src/models/messageQueue.ts","src/models/realm.ts","src/services/checkBrokenConnections/index.ts","src/enums.ts","src/services/messagesExpire/index.ts","src/models/client.ts","src/services/webSocketServer/index.ts","src/messageHandler/handlers/heartbeat/index.ts","src/messageHandler/handlers/transmission/index.ts","src/messageHandler/handlersRegistry.ts","src/messageHandler/index.ts","app.json","src/api/v1/public/index.ts","src/api/index.ts","src/instance.ts","bin/peerjs.ts","src/index.ts"],"sourcesContent":["import type { WebSocketServer, ServerOptions } from \"ws\";\nimport type { CorsOptions } from \"cors\";\n\nexport interface IConfig {\n\treadonly host: string;\n\treadonly port: number;\n\treadonly expire_timeout: number;\n\treadonly alive_timeout: number;\n\treadonly key: string;\n\treadonly path: string;\n\treadonly concurrent_limit: number;\n\treadonly allow_discovery: boolean;\n\treadonly proxied: boolean | string;\n\treadonly cleanup_out_msgs: number;\n\treadonly ssl?: {\n\t\tkey: string;\n\t\tcert: string;\n\t};\n\treadonly generateClientId?: () => string;\n\treadonly createWebSocketServer?: (options: ServerOptions) => WebSocketServer;\n\treadonly corsOptions: CorsOptions;\n}\n\nconst defaultConfig: IConfig = {\n\thost: \"::\",\n\tport: 9000,\n\texpire_timeout: 5000,\n\talive_timeout: 90000,\n\tkey: \"peerjs\",\n\tpath: \"/\",\n\tconcurrent_limit: 5000,\n\tallow_discovery: false,\n\tproxied: false,\n\tcleanup_out_msgs: 1000,\n\tcorsOptions: { origin: true },\n};\n\nexport default defaultConfig;\n","import type { IMessage } from \"./message.ts\";\n\nexport interface IMessageQueue {\n\tgetLastReadAt(): number;\n\n\taddMessage(message: IMessage): void;\n\n\treadMessage(): IMessage | undefined;\n\n\tgetMessages(): IMessage[];\n}\n\nexport class MessageQueue implements IMessageQueue {\n\tprivate lastReadAt: number = new Date().getTime();\n\tprivate readonly messages: IMessage[] = [];\n\n\tpublic getLastReadAt(): number {\n\t\treturn this.lastReadAt;\n\t}\n\n\tpublic addMessage(message: IMessage): void {\n\t\tthis.messages.push(message);\n\t}\n\n\tpublic readMessage(): IMessage | undefined {\n\t\tif (this.messages.length > 0) {\n\t\t\tthis.lastReadAt = new Date().getTime();\n\t\t\treturn this.messages.shift();\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tpublic getMessages(): IMessage[] {\n\t\treturn this.messages;\n\t}\n}\n","import type { IMessageQueue } from \"./messageQueue.ts\";\nimport { MessageQueue } from \"./messageQueue.ts\";\nimport { randomUUID } from \"node:crypto\";\nimport type { IClient } from \"./client.ts\";\nimport type { IMessage } from \"./message.ts\";\n\nexport interface IRealm {\n\tgetClientsIds(): string[];\n\n\tgetClientById(clientId: string): IClient | undefined;\n\n\tgetClientsIdsWithQueue(): string[];\n\n\tsetClient(client: IClient, id: string): void;\n\n\tremoveClientById(id: string): boolean;\n\n\tgetMessageQueueById(id: string): IMessageQueue | undefined;\n\n\taddMessageToQueue(id: string, message: IMessage): void;\n\n\tclearMessageQueue(id: string): void;\n\n\tgenerateClientId(generateClientId?: () => string): string;\n}\n\nexport class Realm implements IRealm {\n\tprivate readonly clients = new Map<string, IClient>();\n\tprivate readonly messageQueues = new Map<string, IMessageQueue>();\n\n\tpublic getClientsIds(): string[] {\n\t\treturn [...this.clients.keys()];\n\t}\n\n\tpublic getClientById(clientId: string): IClient | undefined {\n\t\treturn this.clients.get(clientId);\n\t}\n\n\tpublic getClientsIdsWithQueue(): string[] {\n\t\treturn [...this.messageQueues.keys()];\n\t}\n\n\tpublic setClient(client: IClient, id: string): void {\n\t\tthis.clients.set(id, client);\n\t}\n\n\tpublic removeClientById(id: string): boolean {\n\t\tconst client = this.getClientById(id);\n\n\t\tif (!client) return false;\n\n\t\tthis.clients.delete(id);\n\n\t\treturn true;\n\t}\n\n\tpublic getMessageQueueById(id: string): IMessageQueue | undefined {\n\t\treturn this.messageQueues.get(id);\n\t}\n\n\tpublic addMessageToQueue(id: string, message: IMessage): void {\n\t\tif (!this.getMessageQueueById(id)) {\n\t\t\tthis.messageQueues.set(id, new MessageQueue());\n\t\t}\n\n\t\tthis.getMessageQueueById(id)?.addMessage(message);\n\t}\n\n\tpublic clearMessageQueue(id: string): void {\n\t\tthis.messageQueues.delete(id);\n\t}\n\n\tpublic generateClientId(generateClientId?: () => string): string {\n\t\tconst generateId = generateClientId ? generateClientId : randomUUID;\n\n\t\tlet clientId = generateId();\n\n\t\twhile (this.getClientById(clientId)) {\n\t\t\tclientId = generateId();\n\t\t}\n\n\t\treturn clientId;\n\t}\n}\n","import type { IConfig } from \"../../config/index.ts\";\nimport type { IClient } from \"../../models/client.ts\";\nimport type { IRealm } from \"../../models/realm.ts\";\n\nconst DEFAULT_CHECK_INTERVAL = 300;\n\ntype CustomConfig = Pick<IConfig, \"alive_timeout\">;\n\nexport class CheckBrokenConnections {\n\tpublic readonly checkInterval: number;\n\tprivate timeoutId: NodeJS.Timeout | null = null;\n\tprivate readonly realm: IRealm;\n\tprivate readonly config: CustomConfig;\n\tprivate readonly onClose?: (client: IClient) => void;\n\n\tconstructor({\n\t\trealm,\n\t\tconfig,\n\t\tcheckInterval = DEFAULT_CHECK_INTERVAL,\n\t\tonClose,\n\t}: {\n\t\trealm: IRealm;\n\t\tconfig: CustomConfig;\n\t\tcheckInterval?: number;\n\t\tonClose?: (client: IClient) => void;\n\t}) {\n\t\tthis.realm = realm;\n\t\tthis.config = config;\n\t\tthis.onClose = onClose;\n\t\tthis.checkInterval = checkInterval;\n\t}\n\n\tpublic start(): void {\n\t\tif (this.timeoutId) {\n\t\t\tclearTimeout(this.timeoutId);\n\t\t}\n\n\t\tthis.timeoutId = setTimeout(() => {\n\t\t\tthis.checkConnections();\n\n\t\t\tthis.timeoutId = null;\n\n\t\t\tthis.start();\n\t\t}, this.checkInterval);\n\t}\n\n\tpublic stop(): void {\n\t\tif (this.timeoutId) {\n\t\t\tclearTimeout(this.timeoutId);\n\t\t\tthis.timeoutId = null;\n\t\t}\n\t}\n\n\tprivate checkConnections(): void {\n\t\tconst clientsIds = this.realm.getClientsIds();\n\n\t\tconst now = new Date().getTime();\n\t\tconst { alive_timeout: aliveTimeout } = this.config;\n\n\t\tfor (const clientId of clientsIds) {\n\t\t\tconst client = this.realm.getClientById(clientId);\n\n\t\t\tif (!client) continue;\n\n\t\t\tconst timeSinceLastPing = now - client.getLastPing();\n\n\t\t\tif (timeSinceLastPing < aliveTimeout) continue;\n\n\t\t\ttry {\n\t\t\t\tclient.getSocket()?.close();\n\t\t\t} finally {\n\t\t\t\tthis.realm.clearMessageQueue(clientId);\n\t\t\t\tthis.realm.removeClientById(clientId);\n\n\t\t\t\tclient.setSocket(null);\n\n\t\t\t\tthis.onClose?.(client);\n\t\t\t}\n\t\t}\n\t}\n}\n","export enum Errors {\n\tINVALID_KEY = \"Invalid key provided\",\n\tINVALID_TOKEN = \"Invalid token provided\",\n\tINVALID_WS_PARAMETERS = \"No id, token, or key supplied to websocket server\",\n\tCONNECTION_LIMIT_EXCEED = \"Server has reached its concurrent user limit\",\n}\n\nexport enum MessageType {\n\tOPEN = \"OPEN\",\n\tLEAVE = \"LEAVE\",\n\tCANDIDATE = \"CANDIDATE\",\n\tOFFER = \"OFFER\",\n\tANSWER = \"ANSWER\",\n\tEXPIRE = \"EXPIRE\",\n\tHEARTBEAT = \"HEARTBEAT\",\n\tID_TAKEN = \"ID-TAKEN\",\n\tERROR = \"ERROR\",\n}\n","import { MessageType } from \"../../enums.ts\";\nimport type { IConfig } from \"../../config/index.ts\";\nimport type { IMessageHandler } from \"../../messageHandler/index.ts\";\nimport type { IRealm } from \"../../models/realm.ts\";\n\nexport interface IMessagesExpire {\n\tstartMessagesExpiration(): void;\n\tstopMessagesExpiration(): void;\n}\n\ntype CustomConfig = Pick<IConfig, \"cleanup_out_msgs\" | \"expire_timeout\">;\n\nexport class MessagesExpire implements IMessagesExpire {\n\tprivate readonly realm: IRealm;\n\tprivate readonly config: CustomConfig;\n\tprivate readonly messageHandler: IMessageHandler;\n\n\tprivate timeoutId: NodeJS.Timeout | null = null;\n\n\tconstructor({\n\t\trealm,\n\t\tconfig,\n\t\tmessageHandler,\n\t}: {\n\t\trealm: IRealm;\n\t\tconfig: CustomConfig;\n\t\tmessageHandler: IMessageHandler;\n\t}) {\n\t\tthis.realm = realm;\n\t\tthis.config = config;\n\t\tthis.messageHandler = messageHandler;\n\t}\n\n\tpublic startMessagesExpiration(): void {\n\t\tif (this.timeoutId) {\n\t\t\tclearTimeout(this.timeoutId);\n\t\t}\n\n\t\t// Clean up outstanding messages\n\t\tthis.timeoutId = setTimeout(() => {\n\t\t\tthis.pruneOutstanding();\n\n\t\t\tthis.timeoutId = null;\n\n\t\t\tthis.startMessagesExpiration();\n\t\t}, this.config.cleanup_out_msgs);\n\t}\n\n\tpublic stopMessagesExpiration(): void {\n\t\tif (this.timeoutId) {\n\t\t\tclearTimeout(this.timeoutId);\n\t\t\tthis.timeoutId = null;\n\t\t}\n\t}\n\n\tprivate pruneOutstanding(): void {\n\t\tconst destinationClientsIds = this.realm.getClientsIdsWithQueue();\n\n\t\tconst now = new Date().getTime();\n\t\tconst maxDiff = this.config.expire_timeout;\n\n\t\tconst seen: Record<string, boolean> = {};\n\n\t\tfor (const destinationClientId of destinationClientsIds) {\n\t\t\tconst messageQueue = this.realm.getMessageQueueById(destinationClientId);\n\n\t\t\tif (!messageQueue) continue;\n\n\t\t\tconst lastReadDiff = now - messageQueue.getLastReadAt();\n\n\t\t\tif (lastReadDiff < maxDiff) continue;\n\n\t\t\tconst messages = messageQueue.getMessages();\n\n\t\t\tfor (const message of messages) {\n\t\t\t\tconst seenKey = `${message.src}_${message.dst}`;\n\n\t\t\t\tif (!seen[seenKey]) {\n\t\t\t\t\tthis.messageHandler.handle(undefined, {\n\t\t\t\t\t\ttype: MessageType.EXPIRE,\n\t\t\t\t\t\tsrc: message.dst,\n\t\t\t\t\t\tdst: message.src,\n\t\t\t\t\t});\n\n\t\t\t\t\tseen[seenKey] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.realm.clearMessageQueue(destinationClientId);\n\t\t}\n\t}\n}\n","import type WebSocket from \"ws\";\n\nexport interface IClient {\n\tgetId(): string;\n\n\tgetToken(): string;\n\n\tgetSocket(): WebSocket | null;\n\n\tsetSocket(socket: WebSocket | null): void;\n\n\tgetLastPing(): number;\n\n\tsetLastPing(lastPing: number): void;\n\n\tsend<T>(data: T): void;\n}\n\nexport class Client implements IClient {\n\tprivate readonly id: string;\n\tprivate readonly token: string;\n\tprivate socket: WebSocket | null = null;\n\tprivate lastPing: number = new Date().getTime();\n\n\tconstructor({ id, token }: { id: string; token: string }) {\n\t\tthis.id = id;\n\t\tthis.token = token;\n\t}\n\n\tpublic getId(): string {\n\t\treturn this.id;\n\t}\n\n\tpublic getToken(): string {\n\t\treturn this.token;\n\t}\n\n\tpublic getSocket(): WebSocket | null {\n\t\treturn this.socket;\n\t}\n\n\tpublic setSocket(socket: WebSocket | null): void {\n\t\tthis.socket = socket;\n\t}\n\n\tpublic getLastPing(): number {\n\t\treturn this.lastPing;\n\t}\n\n\tpublic setLastPing(lastPing: number): void {\n\t\tthis.lastPing = lastPing;\n\t}\n\n\tpublic send<T>(data: T): void {\n\t\tthis.socket?.send(JSON.stringify(data));\n\t}\n}\n","import { EventEmitter } from \"node:events\";\nimport type { IncomingMessage } from \"node:http\";\nimport type WebSocket from \"ws\";\nimport { Errors, MessageType } from \"../../enums.ts\";\nimport type { IClient } from \"../../models/client.ts\";\nimport { Client } from \"../../models/client.ts\";\nimport type { IConfig } from \"../../config/index.ts\";\nimport type { IRealm } from \"../../models/realm.ts\";\nimport { WebSocketServer as Server } from \"ws\";\nimport type { Server as HttpServer } from \"node:http\";\nimport type { Server as HttpsServer } from \"node:https\";\nimport { IMessage } from \"../../models/message.js\";\n\nexport interface IWebSocketServer extends EventEmitter {\n\treadonly path: string;\n}\n\ntype CustomConfig = Pick<\n\tIConfig,\n\t\"path\" | \"key\" | \"concurrent_limit\" | \"createWebSocketServer\"\n>;\n\nconst WS_PATH = \"peerjs\";\n\nexport class WebSocketServer extends EventEmitter implements IWebSocketServer {\n\tpublic readonly path: string;\n\tprivate readonly realm: IRealm;\n\tprivate readonly config: CustomConfig;\n\tpublic readonly socketServer: Server;\n\n\tconstructor({\n\t\tserver,\n\t\trealm,\n\t\tconfig,\n\t}: {\n\t\tserver: HttpServer | HttpsServer;\n\t\trealm: IRealm;\n\t\tconfig: CustomConfig;\n\t}) {\n\t\tsuper();\n\n\t\tthis.setMaxListeners(0);\n\n\t\tthis.realm = realm;\n\t\tthis.config = config;\n\n\t\tconst path = this.config.path;\n\t\tthis.path = `${path}${path.endsWith(\"/\") ? \"\" : \"/\"}${WS_PATH}`;\n\n\t\tconst options: WebSocket.ServerOptions = {\n\t\t\tpath: this.path,\n\t\t\tserver,\n\t\t};\n\n\t\tthis.socketServer = config.createWebSocketServer\n\t\t\t? config.createWebSocketServer(options)\n\t\t\t: new Server(options);\n\n\t\tthis.socketServer.on(\"connection\", (socket, req) => {\n\t\t\tthis._onSocketConnection(socket, req);\n\t\t});\n\t\tthis.socketServer.on(\"error\", (error: Error) => {\n\t\t\tthis._onSocketError(error);\n\t\t});\n\t}\n\n\tprivate _onSocketConnection(socket: WebSocket, req: IncomingMessage): void {\n\t\t// An unhandled socket error might crash the server. Handle it first.\n\t\tsocket.on(\"error\", (error) => {\n\t\t\tthis._onSocketError(error);\n\t\t});\n\n\t\t// We are only interested in the query, the base url is therefore not relevant\n\t\tconst { searchParams } = new URL(req.url ?? \"\", \"https://peerjs\");\n\t\tconst { id, token, key } = Object.fromEntries(searchParams.entries());\n\n\t\tif (!id || !token || !key) {\n\t\t\tthis._sendErrorAndClose(socket, Errors.INVALID_WS_PARAMETERS);\n\t\t\treturn;\n\t\t}\n\n\t\tif (key !== this.config.key) {\n\t\t\tthis._sendErrorAndClose(socket, Errors.INVALID_KEY);\n\t\t\treturn;\n\t\t}\n\n\t\tconst client = this.realm.getClientById(id);\n\n\t\tif (client) {\n\t\t\tif (token !== client.getToken()) {\n\t\t\t\t// ID-taken, invalid token\n\t\t\t\tsocket.send(\n\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\ttype: MessageType.ID_TAKEN,\n\t\t\t\t\t\tpayload: { msg: \"ID is taken\" },\n\t\t\t\t\t}),\n\t\t\t\t);\n\n\t\t\t\tsocket.close();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._configureWS(socket, client);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._registerClient({ socket, id, token });\n\t}\n\n\tprivate _onSocketError(error: Error): void {\n\t\t// handle error\n\t\tthis.emit(\"error\", error);\n\t}\n\n\tprivate _registerClient({\n\t\tsocket,\n\t\tid,\n\t\ttoken,\n\t}: {\n\t\tsocket: WebSocket;\n\t\tid: string;\n\t\ttoken: string;\n\t}): void {\n\t\t// Check concurrent limit\n\t\tconst clientsCount = this.realm.getClientsIds().length;\n\n\t\tif (clientsCount >= this.config.concurrent_limit) {\n\t\t\tthis._sendErrorAndClose(socket, Errors.CONNECTION_LIMIT_EXCEED);\n\t\t\treturn;\n\t\t}\n\n\t\tconst newClient: IClient = new Client({ id, token });\n\t\tthis.realm.setClient(newClient, id);\n\t\tsocket.send(JSON.stringify({ type: MessageType.OPEN }));\n\n\t\tthis._configureWS(socket, newClient);\n\t}\n\n\tprivate _configureWS(socket: WebSocket, client: IClient): void {\n\t\tclient.setSocket(socket);\n\n\t\t// Cleanup after a socket closes.\n\t\tsocket.on(\"close\", () => {\n\t\t\tif (client.getSocket() === socket) {\n\t\t\t\tthis.realm.removeClientById(client.getId());\n\t\t\t\tthis.emit(\"close\", client);\n\t\t\t}\n\t\t});\n\n\t\t// Handle messages from peers.\n\t\tsocket.on(\"message\", (data) => {\n\t\t\ttry {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-base-to-string\n\t\t\t\tconst message = JSON.parse(data.toString()) as Writable<IMessage>;\n\n\t\t\t\tmessage.src = client.getId();\n\n\t\t\t\tthis.emit(\"message\", client, message);\n\t\t\t} catch (e) {\n\t\t\t\tthis.emit(\"error\", e);\n\t\t\t}\n\t\t});\n\n\t\tthis.emit(\"connection\", client);\n\t}\n\n\tprivate _sendErrorAndClose(socket: WebSocket, msg: Errors): void {\n\t\tsocket.send(\n\t\t\tJSON.stringify({\n\t\t\t\ttype: MessageType.ERROR,\n\t\t\t\tpayload: { msg },\n\t\t\t}),\n\t\t);\n\n\t\tsocket.close();\n\t}\n}\n\ntype Writable<T> = {\n\t-readonly [K in keyof T]: T[K];\n};\n","import type { IClient } from \"../../../models/client.ts\";\n\nexport const HeartbeatHandler = (client: IClient | undefined): boolean => {\n\tif (client) {\n\t\tconst nowTime = new Date().getTime();\n\t\tclient.setLastPing(nowTime);\n\t}\n\n\treturn true;\n};\n","import { MessageType } from \"../../../enums.ts\";\nimport type { IClient } from \"../../../models/client.ts\";\nimport type { IMessage } from \"../../../models/message.ts\";\nimport type { IRealm } from \"../../../models/realm.ts\";\n\nexport const TransmissionHandler = ({\n\trealm,\n}: {\n\trealm: IRealm;\n}): ((client: IClient | undefined, message: IMessage) => boolean) => {\n\tconst handle = (client: IClient | undefined, message: IMessage) => {\n\t\tconst type = message.type;\n\t\tconst srcId = message.src;\n\t\tconst dstId = message.dst;\n\n\t\tconst destinationClient = realm.getClientById(dstId);\n\n\t\t// User is connected!\n\t\tif (destinationClient) {\n\t\t\tconst socket = destinationClient.getSocket();\n\t\t\ttry {\n\t\t\t\tif (socket) {\n\t\t\t\t\tconst data = JSON.stringify(message);\n\n\t\t\t\t\tsocket.send(data);\n\t\t\t\t} else {\n\t\t\t\t\t// Neither socket no res available. Peer dead?\n\t\t\t\t\tthrow new Error(\"Peer dead\");\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// This happens when a peer disconnects without closing connections and\n\t\t\t\t// the associated WebSocket has not closed.\n\t\t\t\t// Tell other side to stop trying.\n\t\t\t\tif (socket) {\n\t\t\t\t\tsocket.close();\n\t\t\t\t} else {\n\t\t\t\t\trealm.removeClientById(destinationClient.getId());\n\t\t\t\t}\n\n\t\t\t\thandle(client, {\n\t\t\t\t\ttype: MessageType.LEAVE,\n\t\t\t\t\tsrc: dstId,\n\t\t\t\t\tdst: srcId,\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\t// Wait for this client to connect/reconnect (XHR) for important\n\t\t\t// messages.\n\t\t\tconst ignoredTypes = [MessageType.LEAVE, MessageType.EXPIRE];\n\n\t\t\tif (!ignoredTypes.includes(type) && dstId) {\n\t\t\t\trealm.addMessageToQueue(dstId, message);\n\t\t\t} else if (type === MessageType.LEAVE && !dstId) {\n\t\t\t\trealm.removeClientById(srcId);\n\t\t\t} else {\n\t\t\t\t// Unavailable destination specified with message LEAVE or EXPIRE\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t};\n\n\treturn handle;\n};\n","import type { MessageType } from \"../enums.ts\";\nimport type { IClient } from \"../models/client.ts\";\nimport type { IMessage } from \"../models/message.ts\";\nimport type { Handler } from \"./handler.ts\";\n\nexport interface IHandlersRegistry {\n\tregisterHandler(messageType: MessageType, handler: Handler): void;\n\thandle(client: IClient | undefined, message: IMessage): boolean;\n}\n\nexport class HandlersRegistry implements IHandlersRegistry {\n\tprivate readonly handlers = new Map<MessageType, Handler>();\n\n\tpublic registerHandler(messageType: MessageType, handler: Handler): void {\n\t\tif (this.handlers.has(messageType)) return;\n\n\t\tthis.handlers.set(messageType, handler);\n\t}\n\n\tpublic handle(client: IClient | undefined, message: IMessage): boolean {\n\t\tconst { type } = message;\n\n\t\tconst handler = this.handlers.get(type);\n\n\t\tif (!handler) return false;\n\n\t\treturn handler(client, message);\n\t}\n}\n","import { MessageType } from \"../enums.ts\";\nimport { HeartbeatHandler, TransmissionHandler } from \"./handlers/index.ts\";\nimport type { IHandlersRegistry } from \"./handlersRegistry.ts\";\nimport { HandlersRegistry } from \"./handlersRegistry.ts\";\nimport type { IClient } from \"../models/client.ts\";\nimport type { IMessage } from \"../models/message.ts\";\nimport type { IRealm } from \"../models/realm.ts\";\nimport type { Handler } from \"./handler.ts\";\n\nexport interface IMessageHandler {\n\thandle(client: IClient | undefined, message: IMessage): boolean;\n}\n\nexport class MessageHandler implements IMessageHandler {\n\tconstructor(\n\t\trealm: IRealm,\n\t\tprivate readonly handlersRegistry: IHandlersRegistry = new HandlersRegistry(),\n\t) {\n\t\tconst transmissionHandler: Handler = TransmissionHandler({ realm });\n\t\tconst heartbeatHandler: Handler = HeartbeatHandler;\n\n\t\tconst handleTransmission: Handler = (\n\t\t\tclient: IClient | undefined,\n\t\t\t{ type, src, dst, payload }: IMessage,\n\t\t): boolean => {\n\t\t\treturn transmissionHandler(client, {\n\t\t\t\ttype,\n\t\t\t\tsrc,\n\t\t\t\tdst,\n\t\t\t\tpayload,\n\t\t\t});\n\t\t};\n\n\t\tconst handleHeartbeat = (client: IClient | undefined, message: IMessage) =>\n\t\t\theartbeatHandler(client, message);\n\n\t\tthis.handlersRegistry.registerHandler(\n\t\t\tMessageType.HEARTBEAT,\n\t\t\thandleHeartbeat,\n\t\t);\n\t\tthis.handlersRegistry.registerHandler(\n\t\t\tMessageType.OFFER,\n\t\t\thandleTransmission,\n\t\t);\n\t\tthis.handlersRegistry.registerHandler(\n\t\t\tMessageType.ANSWER,\n\t\t\thandleTransmission,\n\t\t);\n\t\tthis.handlersRegistry.registerHandler(\n\t\t\tMessageType.CANDIDATE,\n\t\t\thandleTransmission,\n\t\t);\n\t\tthis.handlersRegistry.registerHandler(\n\t\t\tMessageType.LEAVE,\n\t\t\thandleTransmission,\n\t\t);\n\t\tthis.handlersRegistry.registerHandler(\n\t\t\tMessageType.EXPIRE,\n\t\t\thandleTransmission,\n\t\t);\n\t}\n\n\tpublic handle(client: IClient | undefined, message: IMessage): boolean {\n\t\treturn this.handlersRegistry.handle(client, message);\n\t}\n}\n","{\n\t\"name\": \"PeerJS Server\",\n\t\"description\": \"A server side element to broker connections between PeerJS clients.\",\n\t\"website\": \"https://peerjs.com/\"\n}\n","import express from \"express\";\nimport type { IConfig } from \"../../../config/index.ts\";\nimport type { IRealm } from \"../../../models/realm.ts\";\n\nexport default ({\n\tconfig,\n\trealm,\n}: {\n\tconfig: IConfig;\n\trealm: IRealm;\n}): express.Router => {\n\tconst app = express.Router();\n\n\t// Retrieve guaranteed random ID.\n\tapp.get(\"/id\", (_, res: express.Response) => {\n\t\tres.contentType(\"html\");\n\t\tres.send(realm.generateClientId(config.generateClientId));\n\t});\n\n\t// Get a list of all peers for a key, enabled by the `allowDiscovery` flag.\n\tapp.get(\"/peers\", (_, res: express.Response) => {\n\t\tif (config.allow_discovery) {\n\t\t\tconst clientsIds = realm.getClientsIds();\n\n\t\t\treturn res.send(clientsIds);\n\t\t}\n\n\t\treturn res.sendStatus(401);\n\t});\n\n\treturn app;\n};\n","import cors, { CorsOptions } from \"cors\";\nimport express from \"express\";\nimport publicContent from \"../../app.json\";\nimport PublicApi from \"./v1/public/index.ts\";\nimport type { IConfig } from \"../config/index.ts\";\nimport type { IRealm } from \"../models/realm.ts\";\n\nexport const Api = ({\n\tconfig,\n\trealm,\n\tcorsOptions,\n}: {\n\tconfig: IConfig;\n\trealm: IRealm;\n\tcorsOptions: CorsOptions;\n}): express.Router => {\n\tconst app = express.Router();\n\n\tapp.use(cors(corsOptions));\n\n\tapp.get(\"/\", (_, res) => {\n\t\tres.send(publicContent);\n\t});\n\n\tapp.use(\"/:key\", PublicApi({ config, realm }));\n\n\treturn app;\n};\n","import type express from \"express\";\nimport type { Server as HttpServer } from \"node:http\";\nimport type { Server as HttpsServer } from \"node:https\";\nimport path from \"node:path\";\nimport type { IRealm } from \"./models/realm.ts\";\nimport { Realm } from \"./models/realm.ts\";\nimport { CheckBrokenConnections } from \"./services/checkBrokenConnections/index.ts\";\nimport type { IMessagesExpire } from \"./services/messagesExpire/index.ts\";\nimport { MessagesExpire } from \"./services/messagesExpire/index.ts\";\nimport type { IWebSocketServer } from \"./services/webSocketServer/index.ts\";\nimport { WebSocketServer } from \"./services/webSocketServer/index.ts\";\nimport { MessageHandler } from \"./messageHandler/index.ts\";\nimport { Api } from \"./api/index.ts\";\nimport type { IClient } from \"./models/client.ts\";\nimport type { IMessage } from \"./models/message.ts\";\nimport type { IConfig } from \"./config/index.ts\";\n\nexport interface PeerServerEvents {\n\ton(event: \"connection\", listener: (client: IClient) => void): this;\n\ton(\n\t\tevent: \"message\",\n\t\tlistener: (client: IClient, message: IMessage) => void,\n\t): this;\n\t// eslint-disable-next-line @typescript-eslint/unified-signatures\n\ton(event: \"disconnect\", listener: (client: IClient) => void): this;\n\ton(event: \"error\", listener: (client: Error) => void): this;\n}\n\nexport const createInstance = ({\n\tapp,\n\tserver,\n\toptions,\n}: {\n\tapp: express.Application;\n\tserver: HttpServer | HttpsServer;\n\toptions: IConfig;\n}): void => {\n\tconst config = options;\n\tconst realm: IRealm = new Realm();\n\tconst messageHandler = new MessageHandler(realm);\n\n\tconst api = Api({ config, realm, corsOptions: options.corsOptions });\n\tconst messagesExpire: IMessagesExpire = new MessagesExpire({\n\t\trealm,\n\t\tconfig,\n\t\tmessageHandler,\n\t});\n\tconst checkBrokenConnections = new CheckBrokenConnections({\n\t\trealm,\n\t\tconfig,\n\t\tonClose: (client) => {\n\t\t\tapp.emit(\"disconnect\", client);\n\t\t},\n\t});\n\n\tapp.use(options.path, api);\n\n\t//use mountpath for WS server\n\tconst customConfig = {\n\t\t...config,\n\t\tpath: path.posix.join(app.path(), options.path, \"/\"),\n\t};\n\n\tconst wss: IWebSocketServer = new WebSocketServer({\n\t\tserver,\n\t\trealm,\n\t\tconfig: customConfig,\n\t});\n\n\twss.on(\"connection\", (client: IClient) => {\n\t\tconst messageQueue = realm.getMessageQueueById(client.getId());\n\n\t\tif (messageQueue) {\n\t\t\tlet message: IMessage | undefined;\n\n\t\t\twhile ((message = messageQueue.readMessage())) {\n\t\t\t\tmessageHandler.handle(client, message);\n\t\t\t}\n\t\t\trealm.clearMessageQueue(client.getId());\n\t\t}\n\n\t\tapp.emit(\"connection\", client);\n\t});\n\n\twss.on(\"message\", (client: IClient, message: IMessage) => {\n\t\tapp.emit(\"message\", client, message);\n\t\tmessageHandler.handle(client, message);\n\t});\n\n\twss.on(\"close\", (client: IClient) => {\n\t\tapp.emit(\"disconnect\", client);\n\t});\n\n\twss.on(\"error\", (error: Error) => {\n\t\tapp.emit(\"error\", error);\n\t});\n\n\tmessagesExpire.startMessagesExpiration();\n\tcheckBrokenConnections.start();\n};\n","#!/usr/bin/env node\n\nimport path from \"node:path\";\nimport fs from \"node:fs\";\nconst optimistUsageLength = 98;\nimport yargs from \"yargs\";\nimport { hideBin } from \"yargs/helpers\";\nimport { PeerServer } from \"../src/index.ts\";\nimport type { AddressInfo } from \"node:net\";\nimport type { CorsOptions } from \"cors\";\n\nconst y = yargs(hideBin(process.argv));\n\nconst portEnvIsSet = !!process.env[\"PORT\"];\n\nconst opts = y\n\t.usage(\"Usage: $0\")\n\t.wrap(Math.min(optimistUsageLength, y.terminalWidth()))\n\t.options({\n\t\texpire_timeout: {\n\t\t\tdemandOption: false,\n\t\t\talias: \"t\",\n\t\t\tdescribe: \"timeout (milliseconds)\",\n\t\t\tdefault: 5000,\n\t\t},\n\t\tconcurrent_limit: {\n\t\t\tdemandOption: false,\n\t\t\talias: \"c\",\n\t\t\tdescribe: \"concurrent limit\",\n\t\t\tdefault: 5000,\n\t\t},\n\t\talive_timeout: {\n\t\t\tdemandOption: false,\n\t\t\tdescribe: \"broken connection check timeout (milliseconds)\",\n\t\t\tdefault: 60000,\n\t\t},\n\t\tkey: {\n\t\t\tdemandOption: false,\n\t\t\talias: \"k\",\n\t\t\tdescribe: \"connection key\",\n\t\t\tdefault: \"peerjs\",\n\t\t},\n\t\tsslkey: {\n\t\t\ttype: \"string\",\n\t\t\tdemandOption: false,\n\t\t\tdescribe: \"path to SSL key\",\n\t\t},\n\t\tsslcert: {\n\t\t\ttype: \"string\",\n\t\t\tdemandOption: false,\n\t\t\tdescribe: \"path to SSL certificate\",\n\t\t},\n\t\thost: {\n\t\t\ttype: \"string\",\n\t\t\tdemandOption: false,\n\t\t\talias: \"H\",\n\t\t\tdescribe: \"host\",\n\t\t},\n\t\tport: {\n\t\t\ttype: \"number\",\n\t\t\tdemandOption: !portEnvIsSet,\n\t\t\talias: \"p\",\n\t\t\tdescribe: \"port\",\n\t\t},\n\t\tpath: {\n\t\t\ttype: \"string\",\n\t\t\tdemandOption: false,\n\t\t\tdescribe: \"custom path\",\n\t\t\tdefault: process.env[\"PEERSERVER_PATH\"] ?? \"/\",\n\t\t},\n\t\tallow_discovery: {\n\t\t\ttype: \"boolean\",\n\t\t\tdemandOption: false,\n\t\t\tdescribe: \"allow discovery of peers\",\n\t\t},\n\t\tproxied: {\n\t\t\ttype: \"boolean\",\n\t\t\tdemandOption: false,\n\t\t\tdescribe: \"Set true if PeerServer stays behind a reverse proxy\",\n\t\t\tdefault: false,\n\t\t},\n\t\tcors: {\n\t\t\ttype: \"string\",\n\t\t\tarray: true,\n\t\t\tdescribe: \"Set the list of CORS origins\",\n\t\t},\n\t})\n\t.boolean(\"allow_discovery\")\n\t.parseSync();\n\nif (!opts.port) {\n\t// .port is only not set if the PORT env var is set\n\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\topts.port = parseInt(process.env[\"PORT\"]!);\n}\nif (opts.cors) {\n\topts[\"corsOptions\"] = {\n\t\torigin: opts.cors,\n\t} satisfies CorsOptions;\n}\nprocess.on(\"uncaughtException\", function (e) {\n\tconsole.error(\"Error: \" + e.toString());\n});\n\nif (opts.sslkey ?? opts.sslcert) {\n\tif (opts.sslkey && opts.sslcert) {\n\t\topts[\"ssl\"] = {\n\t\t\tkey: fs.readFileSync(path.resolve(opts.sslkey)),\n\t\t\tcert: fs.readFileSync(path.resolve(opts.sslcert)),\n\t\t};\n\t} else {\n\t\tconsole.error(\n\t\t\t\"Warning: PeerServer will not run because either \" +\n\t\t\t\t\"the key or the certificate has not been provided.\",\n\t\t);\n\t\tprocess.exit(1);\n\t}\n}\n\nconst userPath = opts.path;\nconst server = PeerServer(opts, (server) => {\n\tconst { address: host, port } = server.address() as AddressInfo;\n\n\tconsole.log(\n\t\t\"Started PeerServer on %s, port: %s, path: %s\",\n\t\thost,\n\t\tport,\n\t\tuserPath || \"/\",\n\t);\n\n\tconst shutdownApp = () => {\n\t\tserver.close(() => {\n\t\t\tconsole.log(\"Http server closed.\");\n\n\t\t\tprocess.exit(0);\n\t\t});\n\t};\n\n\tprocess.on(\"SIGINT\", shutdownApp);\n\tprocess.on(\"SIGTERM\", shutdownApp);\n});\n\nserver.on(\"connection\", (client) => {\n\tconsole.log(`Client connected: ${client.getId()}`);\n});\n\nserver.on(\"disconnect\", (client) => {\n\tconsole.log(`Client disconnected: ${client.getId()}`);\n});\n","import express, { type Express } from \"express\";\nimport http from \"node:http\";\nimport https from \"node:https\";\n\nimport type { IConfig } from \"./config/index.ts\";\nimport defaultConfig from \"./config/index.ts\";\nimport type { PeerServerEvents } from \"./instance.ts\";\nimport { createInstance } from \"./instance.ts\";\nimport type { IClient } from \"./models/client.ts\";\nimport type { IMessage } from \"./models/message.ts\";\n\nexport type { MessageType } from \"./enums.ts\";\nexport type { IConfig, PeerServerEvents, IClient, IMessage };\n\nfunction ExpressPeerServer(\n\tserver: https.Server | http.Server,\n\toptions?: Partial<IConfig>,\n) {\n\tconst app = express();\n\n\tconst newOptions: IConfig = {\n\t\t...defaultConfig,\n\t\t...options,\n\t};\n\n\tif (newOptions.proxied) {\n\t\tapp.set(\n\t\t\t\"trust proxy\",\n\t\t\tnewOptions.proxied === \"false\" ? false : !!newOptions.proxied,\n\t\t);\n\t}\n\n\tapp.on(\"mount\", () => {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\t\tif (!server) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Server is not passed to constructor - \" + \"can't start PeerServer\",\n\t\t\t);\n\t\t}\n\n\t\tcreateInstance({ app, server, options: newOptions });\n\t});\n\n\treturn app as Express & PeerServerEvents;\n}\n\nfunction PeerServer(\n\toptions: Partial<IConfig> = {},\n\tcallback?: (server: https.Server | http.Server) => void,\n) {\n\tconst app = express();\n\n\tlet newOptions: IConfig = {\n\t\t...defaultConfig,\n\t\t...options,\n\t};\n\n\tconst port = newOptions.port;\n\tconst host = newOptions.host;\n\n\tlet server: https.Server | http.Server;\n\n\tconst { ssl, ...restOptions } = newOptions;\n\tif (ssl && Object.keys(ssl).length) {\n\t\tserver = https.createServer(ssl, app);\n\n\t\tnewOptions = restOptions;\n\t} else {\n\t\tserver = http.createServer(app);\n\t}\n\n\tconst peerjs = ExpressPeerServer(server, newOptions);\n\tapp.use(peerjs);\n\n\tserver.listen(port, host, () => callback?.(server));\n\n\treturn peerjs;\n}\n\nexport { ExpressPeerServer, PeerServer };\n"],"names":["$aeb1147dec1b7a02$export$2e2bcd8739ae039","host","port","expire_timeout","alive_timeout","key","path","concurrent_limit","allow_discovery","proxied","cleanup_out_msgs","corsOptions","origin","$2c42eaf0ccc66758$export$eb4c623330d4cbcc","lastReadAt","Date","getTime","messages","getLastReadAt","this","addMessage","message","push","readMessage","length","shift","getMessages","$0a339ca52e0451c9$export$3ee29d34e33d9116","clients","Map","messageQueues","getClientsIds","keys","getClientById","clientId","get","getClientsIdsWithQueue","setClient","client","id","set","removeClientById","delete","getMessageQueueById","addMessageToQueue","clearMessageQueue","generateClientId","generateId","$7BbP7$randomUUID","$6840aafc61c9abd6$export$6fa53df6b5b88df7","timeoutId","constructor","realm","config","checkInterval","onClose","start","clearTimeout","setTimeout","checkConnections","stop","clientsIds","now","aliveTimeout","getLastPing","getSocket","close","setSocket","$d461d7260b6fc353$export$b8e9cd941e8016ac","Errors","$d461d7260b6fc353$export$80edbf15fa61a4db","MessageType","$c97baf9b78981954$export$a13b411d0e88b1af","messageHandler","startMessagesExpiration","pruneOutstanding","stopMessagesExpiration","destinationClientsIds","maxDiff","seen","destinationClientId","messageQueue","seenKey","src","dst","handle","undefined","type","EXPIRE","$d09fcb6ab78a3f48$export$1f2bb630327ac4b6","socket","lastPing","token","getId","getToken","setLastPing","send","data","JSON","stringify","$4ae24f8b3b7cf7b0$export$f47674b57e51ee3b","$7BbP7$EventEmitter","server","super","setMaxListeners","endsWith","options","socketServer","createWebSocketServer","$7BbP7$WebSocketServer","on","req","_onSocketConnection","error","_onSocketError","searchParams","URL","url","Object","fromEntries","entries","_sendErrorAndClose","INVALID_WS_PARAMETERS","INVALID_KEY","ID_TAKEN","payload","msg","_configureWS","_registerClient","emit","CONNECTION_LIMIT_EXCEED","newClient","OPEN","parse","toString","e","ERROR","$c523c19e3fc944a1$export$65302b915833a46d","nowTime","$879e80f95ec634eb$export$809c011ea942310","srcId","dstId","destinationClient","Error","LEAVE","includes","$df0509eaca4ae82c$export$cfe4a96645b0bbcf","handlers","registerHandler","messageType","handler","has","$3089a9bad51bbb04$export$3deceafe0aaeaa95","handlersRegistry","transmissionHandler","heartbeatHandler","handleTransmission","HEARTBEAT","OFFER","ANSWER","CANDIDATE","$264fdbd7932d14df$exports","$6910ff2a5db5006f$export$2e2bcd8739ae039","app","$7BbP7$express","Router","_","res","contentType","sendStatus","$69f9994c6ebd6802$export$bf71da7aebe9ddc1","use","$7BbP7$cors","$parcel$interopDefault","$e7d4fd16baa81890$export$99152e8d49ca4e7d","api","messagesExpire","checkBrokenConnections","customConfig","$7BbP7$nodepath","posix","join","wss","$3809f3d53201df9f$var$y","$7BbP7$yargs","$7BbP7$hideBin","process","argv","$3809f3d53201df9f$var$portEnvIsSet","env","$3809f3d53201df9f$var$opts","usage","wrap","Math","min","terminalWidth","demandOption","alias","describe","default","sslkey","sslcert","cors","array","boolean","parseSync","parseInt","console","$7BbP7$nodefs","readFileSync","resolve","cert","exit","$3809f3d53201df9f$var$userPath","$3809f3d53201df9f$var$server","callback","newOptions","ssl","restOptions","$7BbP7$nodehttps","createServer","$7BbP7$nodehttp","peerjs","$0fe9c43b5c368182$export$8c57434a18c696c9","listen","address","log","shutdownApp"],"version":3,"file":"peerjs.js.map","sourceRoot":"../../"}